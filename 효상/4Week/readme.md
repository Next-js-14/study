# 4Week

## 1. react-query SSR 설정하기

### ReactQuery Provider 설정

- 데이터 패칭은 로그인 이후에만 일어나기 때문에 로그인 이후 그룹에만 적용시키기 위해 (afterLogin)/_component 하위에 Provider를 만든다.
- 로그인 이후의 layout에서 <main> 부분에 데이터가 오가기 때문에 적당히 감싸 Provider를 적용시킨다.

## 2. 클라이언트 react-query

### PostRecommends 컴포넌트

- Home 페이지에서 prefetch 시에 서버로부터 데이터를 받아와서 그려줌
- useQuery를 사용해서 해당 데이터를 사용하는 PostRecommends 컴포넌트를 정의

## 3. react-query를 쓰는 이유와 fresh, stale inactive

### react-query VS redux

- react-query의 핵심은 서버에서 데이터를 가져오는 것, redux의 핵심은 컴포넌트간에 데이터를 공유하는 것
- react-query 는 추가적으로 서버의 로딩 상태 등도 가져올 수 있음 (개인 경험)
- 데이터 통신에는 loading과 success, failed라는 상태가 있는데, react-query에서는 표준 API로 사용할 수 있어서 개발자 입장에서는 매우 편리
- queryKey 또한 장점이다. key를 통해 데이터를 한번에 갱신하거나 관리할 수 있어 개발자 입장에서 편리
- 데이터의 사용량이 늘어나면서 트래픽 관리를 잘 해주어야 하는데, 이때 캐싱을 잘 해주어야
- react-query는 캐싱에 대해 잘 관리해주기 때문에 이에 대한 이점이 있다.

### react-query에서의 데이터 상태

- Fresh : 항상 최신 데이터 , 업데이트 불필요 (서버 통신 불필요)
  데이터가 fresh 상태일 경우 새로고침 시 등의 동작이 있을 경우, 다시 서버에 데이터를 요청하지 않는다.
- Stale : 개발자의 조건에 따라 데이터를 새로 가져온다.
  새로고침이 될 경우 서버에 다시 요청해 데이터를 받아온다.
- Inactive : 사용자가 보고 있는 화면에서 해당 queryKey를 사용하는 query가 쓰이지 않는다면 inactive 상태가 된다.
- fetching : 데이터를 가져오는 중
- Pauesd : 데이터를 가지고 오는게 일시정지

## 추가 : CSR && SSR
출처: https://hahahoho5915.tistory.com/52 [넌 잘하고 있어:티스토리]

### 저번 스터디에서 SSR && CSR 에 대해서 잠깐 얘기 했던 거 같은데 중요한 개념이라서 추가 정리

### SSR : Server Side Rendering

- 서버쪽에서 렌더링이 끝난 후 클라이언트에 전달

![image](https://github.com/Next-js-14/study/assets/120166018/881f50b6-0b1f-49b2-bde4-570a4ad6af03)

1. User가 Website 요청을 보냄.
2. Server는 'Ready to Render'. 즉, 즉시 렌더링 가능한 html파일을 만든다. (리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.) 
3. 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다. 그러나 사이트 자체는 조작 불가능하다. (Javascript가 읽히기 전이다.)
4. 클라이언트가 자바스크립트를 다운받는다. 
5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다. 
6. 브라우저가 Javascript 프레임워크를 실행한다. 7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.

### CSR : Client Side Rendering

- 클라이언트 측에서 렌더링

![image](https://github.com/Next-js-14/study/assets/120166018/d4466905-fcc6-4ef6-9355-390669746cdd)

1. User가 Website 요청을 보냄. 
2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다. CDN : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식 
3. 클라이언트는 HTML과 JS를 다운로드 받는다. (이때 SSR과 달리 유저는 아무것도 볼 수 없다.) 
4. 생략 
5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다. (이때 유저들은 placeholder를 보게된다.) 
6. 서버가 API로부터의 요청에 응답한다. 7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

### CSR vs SSR

1. 웹페이지를 로딩하는 시간

웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다. 하나는 웹 사이트의 가장 첫 페이지를 로딩하는 것.
다른 하나는 나머지를 로딩하는 것 

1) 첫 페이지 로딩시간

- CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다.
- 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. 
- 따라서 평균적으로 SSR이 더 빠르다. 

2) 나머지 로딩 시간 

- 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자.
- CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.
- 반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.

2. SEO 대응

검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽는다.
CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에
자바스크립트가 실행 되어야 meatadata가 바뀌었다. (이전 크롤러들은 자바스크립트를 실행시키지 않았었기에 SEO 최적화가 필수적이었다. 구글이 그 트렌드를 바꾸고 있다고 한다.) SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.

3. 서버 자원 사용 SSR이 서버 자원을 더 많이 사용한다.

매번 서버에 요청을 하기 때문이다. 리엑트로 구현할 때는 다음과 같은 문제가 생기기도 한다. 
- renderToStrng은 React에서 서버사이드 렌더링을 구현하는데 사용되는 메소드다.
그런데 이게 스택을 막고 동기적으로 처리된다.
이게 실행될 동안 서버는 멈춘다. 😢

참고 renderToString은 리액트가 버전업이 되면서 '클라이언트에서'의 퍼포먼스가 개선되었다.

### 결론

- 매번 논란이 있긴 하지만 서비스의 성격따라서 더 유리한 렌더링 방식이 다르다.

- SSR

1. 페이지를 넘길때 마다 로딩을 하기 때문에 더 느리지만 굳이 빠른 속도가 필요없는 경우
2. 서버의 안정성과 결합이 더욱 중요한 서비스의 경우
3. 페이지의 잦은 이동이 필요 없는 경우
4. 서버 자원을 더 많이 사용해도 괜찮을 정도의 서버 운용 능력이 되는 경우
5. 비즈니스 백오피스 등 B2B 혹은 내부인원 사용 베이스의 사이트

- CSR

1. 처음 페이지 로딩은 느리지만 다른 페이지로 이동을 할 경우
2. 서버의 안정성과 서버와의 결합 보다는 당장 보여주는 요소의 중요성이 큰 경우
3. 페이지의 잦은 이동이 필요한 경우
4. 적은 서버 리소스로 웹사이트 구현이 필요한 경우
5. 잦은 페이지 이동이 많은 쇼핑몰 , 혹은 가벼운 서비스 (앱 처럼 동작하는 서비스들)